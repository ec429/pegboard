init.s gets built to address 0.  All CPUs will enter it as soon as they come online; and they will all have the same SP, so it has to be careful how it uses the stack.  (Until the SP fixup, we only ever call one function - spin_lock - and we never PUSH.)  When init is done (and calls main), each CPU has its own 256-byte stack, at the top of which is a struct percpu_struct (a pointer to this is stored in IY) containing, at present, the cpuid and nothing else.  cpuid assignment is done on a first-come-first-served basis, and if all CPUs are started together their cpuids may be different on each boot.

spinlock.s provides a simple spinlock based around the instruction 'lock sra (IX+0)'.  It was inspired by http://u6c87.blogspot.co.uk/2011/10/atomic-instructions-on-z80-for-locking.html but that article only considers UP; for SMP the lock prefix had to be added to ensure the MMU doesn't let someone else in during our read-modify-write.  Spinlocks tend to perform poorly under contention, and this is certainly the case here; since a locked op blocks _all_ other memory traffic, a herd of CPUs trying to acquire the lock can significantly slow down the release path, leading to O(nÂ²) thrashing.  Fortunately, it should be possible to loosen the locked-op rules while maintaining correctness, at the cost of increased MMU complexity; this could reduce the performance penalty significantly.

Allocation bitmap is stored in page 1: up to 254 bytes starting at offset 2, each containing the PID of the page owner (or 0 for free pages).  While at offset 0 we have the lock, and at offset 1 the number of free pages.

Next steps:
	Functions to allocate and free pages.
	Implement a scheduler, and some sleeping locks (semaphores).
	Write useful print routines (a simple printk?)
	Devise a scheme for IPIs.
	Write a panic() function, for when things go wrong.
